# -*- coding: utf-8 -*-
"""Ordenamientos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RQnrZTGNXHCYgMk2CPqbRIo2l8FrHlX8

* Algoritmo búsqueda binaria --> Python
* Algoritmo BucketSort --> Python
* Algoritmo Megesort --> Python
* Algoritmo Quicksort --> Python
* Algoritmo burbuja --> Python
* Proyecto final
* Algoritmo de la Subcadena común más larga --> Java
* Segunda asignación
* Primera asignación
"""

#Algoritmo Burbuja
Lista = [228,230,230,227,229,230,231,228,225,226]
def Burbuja(Lista):
    for i in range(len(Lista)):
        for j in range(len(Lista)-1):
            if(Lista[j]>Lista[j+1]):
                Lista[j],Lista[j+1]=Lista[j+1],Lista[j]
    return Lista
Burbuja(Lista)

#Algoritmo Quicksort
def seleccionarPivote(Lista,prom=True):
    if(prom):
        return sum(Lista)/len(Lista)
    else:
        return (Lista[0]+Lista[-1])/2

def Dividir(Lista,p):
    Lmen=[]
    Lmay=[]
    for e in Lista:
        if(e>p):
            Lmay.append(e)
        else:
            Lmen.append(e)
    return Lmen,Lmay

def repetidos(Lista):
    for i in range(len(Lista)-1):
        if(not Lista[i]==Lista[i+1]):
            return False
    return True

def Quicksort(Lista):
    if(len(Lista)>=2 and not repetidos(Lista)):
        p=seleccionarPivote(Lista)
        Lmen,Lmay=Dividir(Lista,p)
        Lmen=Quicksort(Lmen)
        Lmay=Quicksort(Lmay)
        return Lmen+Lmay
    else:
        return Lista

Quicksort(Lista)

#Algoritmo MergeSort
def MergeSort(Lista):
    if(len(Lista)>=2 and not repetidos(Lista)):
        ListaA,ListaB = DividirM(Lista)
        ListaA=MergeSort(ListaA)
        ListaB=MergeSort(ListaB)
        return Merge(ListaA,ListaB)
    else:
        return Lista

def Merge(ListaA,ListaB):
    R=[]
    while(len(ListaA)>0 and len(ListaB)>0):
        if(ListaA[0]<ListaB[0]):
            R.append(ListaA[0])
            ListaA.pop(0)
        else:
            R.append(ListaB[0])
            ListaB.pop(0)
    return R+ListaA+ListaB

def DividirM(Lista):
    n=len(Lista)
    return Lista[0:int(n/2)],Lista[int(n/2):]

MergeSort(Lista)

#Algoritmo BucketSort
def BucketSort(Lista):
    mayor=Lista[0]
    menor=Lista[0]
    for i in range(len(Lista)):
        if(mayor<Lista[i]):
            mayor=Lista[i]
        if(menor>Lista[i]):
            menor=Lista[i]
    t=mayor-menor+1
    buckets=[]
    for i in range(t):
        buckets.append(0)
    for e in Lista:
        buckets[e-menor]+=1
    for i in range(len(buckets)):
        if(not buckets[i]==0):
            for j in range(buckets[i]):
                print(i+menor, end=" ")

BucketSort(Lista)

#Algoritmo busqueda binaria
#Cuadrado magico 3x3
class arbol:
    def __init__(self,nodo):
        self.raiz = nodo

class nodo:
    def __init__(self,cont,conteo):
        self.contenido = cont
        self.conteo=conteo
        self.hijos = []
    def añadeHijos(self,n):
        for i in range(9):
            j=int(i/3)
            k=i%3
            if(self.contenido[j][k]==0):
                contHijo = []
                conteoHijo = self.conteo
                contHijo.append(self.contenido[0].copy())
                contHijo.append(self.contenido[1].copy())
                contHijo.append(self.contenido[2].copy())
                contHijo[j][k]=n+1
                nod = nodo(contHijo,conteoHijo)
                if(comprueba(contHijo)):
                    nod.añadeHijos(n+1)
                    if(n==8):
                        self.conteo[0]+=1
                        #print(contHijo)
                        sumaBien(contHijo)
                self.hijos.append(nod)

def comprueba(cont):
    filasBien = compruebaFilas(cont)
    columnasBien = compruebaColumnas(cont)
    diagBien = compruebaDiag(cont)
    return filasBien and columnasBien and diagBien

def compruebaFilas(cont):
    for e in cont:
        if(not 0 in e):
            if(not sum(e)==15):
                return False
    return True

def compruebaColumnas(cont):
    k=0
    while(k<3):
        suma = 0
        j=0
        while(j<3 and j>0):
            if(cont[j][k]==0):
                j=-1
            else:
                suma+=cont[j][k]
            j+=1
        if(j==3):
            if(not suma == 15):
                return False
        k+=1
    return True

def compruebaDiag(cont):
    diag1=[cont[0][0],cont[1][1],cont[2][2]]
    diag2=[cont[2][0],cont[1][1],cont[0][2]]

    if(not 0 in diag1):
        if(not sum(diag1)==15):
            return False

    if(not 0 in diag2):
        if(not sum(diag2)==15):
            return False

    return True

def sumaBien(contHijo):
    if((contHijo[0][0])+(contHijo[1][0])+(contHijo[2][0])==15):
        if((contHijo[0][1])+(contHijo[1][1])+(contHijo[2][1])==15):
            if((contHijo[0][2])+(contHijo[1][2])+(contHijo[2][2])==15):
                print(contHijo)

A = arbol(nodo([[0,0,0],[0,0,0],[0,0,0]],[0]))
A.raiz.añadeHijos(0)

"""
Se tiene una mochila con capacidad máxima W. Y se tiene un conjunto de objetos
O que está compuesto por objetos oi={pi,bi}, dónde pi es el peso del objeto i
y bi es el beneficio que me da llevar el objeto i en la mochila.

Para cualquier conjunto de objetos O. Encontrar un algoritmo que siempre me de
la configuración con beneficio máximo que puedo llevar.
"""

"""
Inicio
Definir la capacidad maxima de W
Definir arreglo de objetos con peso y beneficio
Mientras no pase por todos los elementos del arreglo
    si existe una mochila
        copiar todas las mochilas existentes cambiando el ultimo valor por el siguiente que le sigue
        agregar siguiente elemento
    sino
        crear una mochila agregando un elemento



"""

